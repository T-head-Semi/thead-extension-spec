[#xtheadmatrix-extensions]
=== Sub-extensions

There are two sub-extensions defined for XTheadMatrix:

* XTheadMatrixBf16 (bf16 extension)
* XTheadMatrixInt4 (int4 extension)

==== XTheadMatrixBf16

The 16-bit float operand can be seen as
Bfloat-16 format. The bf16 extension adds a bit in FCSR, the 16-bit float
data is bf16 if the bit is set to 1.

....
#float matrix multiplication, md = md + ms1*ms2
th.fmmacc.h md, ms2, ms1
#float matrix multiplication, output widen, md = md + ms1*ms2
th.fwmmacc.h md, ms2, ms1
....
16 bit float pointwise operations and 16 bit float integer conversion operations are optionally supported.

==== XTheadMatrixInt4

For int4 matrix multiplication, the source operand is 4-bit width and
the destination is 32-bit width. Two int4 data pair are considered as an
8-bit element, the sizeK is set as int8 data width, so the K should be
an even value, otherwise reserved.

* th.pmmaqa.b/th.pmmaqau.b/th.pmmaqaus.b/th.pmmaqasu.b: int4 8x widen matrix
multiplication and add , illegal if bit[0] of xmisa register is 0
* for conversion between int8 and int4,  legal if bit[28] and bit[0] of xmisa register are both set to 1, also legal if bit[28] and bit[0] of xmisa register are both set to 1, illegal In all other cases

The maximum matrix shape is:

* matrixA: M <= RLEN/32, K <= RLEN/4
* matrixB: N <= RLEN/32, K <= RLEN/4
* matrixC: M <= RLEN/32, N <= RLEN/32

....
#4bit data width
#signed matrix multiply
th.pmmaqa.b ms3, ms2, ms1
#unsigned matrix multiply
th.pmmaqau.b ms3, ms2, ms1
#unsigned-signed matrix multiply
th.pmmaqaus.b ms3, ms2, ms1
#signed-unsigned matrix multiply
th.pmmaqasu.b ms3, ms2, ms1
....

[width="100%",cols="1,1,1,2,1,1,2,1,1,2",options="header",]
|===
| 3+^|matrix A 3+^|matrix B 3+^|matrix C
|RLEN |M |K |data width |N |K |data width |M |N |data width

|128 |4 |32 |512 bits |4 |32 |512 bits |4 |4 |512 bits

|256 |8 |64 |2048 bits |8 |64 |2048 bits |8 |8 |2048 bits

|512 |16 |128 |8192 bits |16 |128 |8192 bits |16 |16 |8192 bits
|===

The int4 matrix multiplication instruction uses arithmetic instructions format, the code is as follows:
[width="100%",cols="1,1,1,1,1,1,1,1,1,1,1",options="header",]
|===
|31  27|26  25|24|23  21|20  18|17  15|14  12|11  10|9    7|6    0|
|00010 |00| 1|ms2 |ms1 |md/ms3 |func3 |00 |000 |major opcode|pmmaqa.b
|00010 |00| 1|ms2 |ms1 |md/ms3 |func3 |00 |001 |major opcode|pmmaqau.b
|00010 |00| 1|ms2 |ms1 |md/ms3 |func3 |00 |010 |major opcode|pmmaqaus.b
|00010 |00| 1|ms2 |ms1 |md/ms3 |func3 |00 |011 |major opcode|pmmaqasu.b
|===

Integer conversion instruction is optionally supported in int4 extension. As data width for destination matrix is twice that of source matrix, two matrix register(register-pair) are used by destination matrix specified by md and md+1. Instructions specifying an odd-numbered md is reserved.

....
#4bit data width
#signed matrix multiply
th.pmmaqa.b ms3, ms2, ms1
#unsigned matrix multiply
th.pmmaqau.b ms3, ms2, ms1
#unsigned-signed matrix multiply
th.pmmaqaus.b ms3, ms2, ms1
#signed-unsigned matrix multiply
th.pmmaqasu.b ms3, ms2, ms1
....

The integer conversion instruction uses arithmetic instructions format, the code is as follows:

|===
|31  27|26  25|24|23  21|20  18|17  15|14  12|11  10|9    7|6    0|
|10111 |00| 1|000 |ms1 |md |func3 |00 |000 |major opcode|th.pmswcvt
|10111 |00| 1|000 |ms1 |md |func3 |00 |001 |major opcode|th.pmuwcvt
|===

